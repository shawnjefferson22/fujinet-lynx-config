ca65 V2.18 - Ubuntu 2.19-1
Main file   : lynxfnio.s
Current file: lynxfnio.s

000000r 1               ;
000000r 1               ; File generated by cc65 v 2.18 - Ubuntu 2.19-1
000000r 1               ;
000000r 1               	.fopt		compiler,"cc65 v 2.18 - Ubuntu 2.19-1"
000000r 1               	.setcpu		"65SC02"
000000r 1               	.smart		on
000000r 1               	.autoimport	on
000000r 1               	.case		on
000000r 1               	.debuginfo	off
000000r 1               	.importzp	sp, sreg, regsave, regbank
000000r 1               	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
000000r 1               	.macpack	longbranch
000000r 2               .macro  jeq     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                       bne     *+5
000000r 2                       jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               beq     Target
000000r 2                       .else
000000r 2                               bne     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jne     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               beq     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bne     Target
000000r 2                       .else
000000r 2                               beq     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jmi     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bpl     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bmi     Target
000000r 2                       .else
000000r 2                               bpl     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jpl     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bmi     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bpl     Target
000000r 2                       .else
000000r 2                               bmi     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jcs     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bcc     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bcs     Target
000000r 2                       .else
000000r 2                               bcc     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jcc     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bcs     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bcc     Target
000000r 2                       .else
000000r 2                               bcs     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jvs     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bvc     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bvs     Target
000000r 2                       .else
000000r 2                               bvc     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jvc     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bvs     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bvc     Target
000000r 2                       .else
000000r 2                               bvs     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               
000000r 1               	.import		_lynx_comlynx_ser
000000r 1               	.import		_ser_install
000000r 1               	.import		_ser_open
000000r 1               	.import		_ser_close
000000r 1               	.import		_ser_get
000000r 1               	.import		_ser_put
000000r 1               	.export		__ck
000000r 1               	.export		__r
000000r 1               	.export		__checksum
000000r 1               	.export		__serial_get_loop
000000r 1               	.export		_fnio_init
000000r 1               	.export		_fnio_done
000000r 1               	.export		_fnio_reset
000000r 1               	.export		_fnio_status
000000r 1               	.export		_fnio_send
000000r 1               	.export		_fnio_recv
000000r 1               	.export		_fnio_cts
000000r 1               
000000r 1               .segment	"BSS"
000000r 1               
000000r 1               __ck:
000000r 1  00           	.res	1,$00
000001r 1               __r:
000001r 1  00           	.res	1,$00
000002r 1               
000002r 1               ; ---------------------------------------------------------------
000002r 1               ; void __near__ _checksum (__near__ unsigned char *, unsigned short)
000002r 1               ; ---------------------------------------------------------------
000002r 1               
000002r 1               .segment	"CODE"
000000r 1               
000000r 1               .proc	__checksum: near
000000r 1               
000000r 1               .segment	"CODE"
000000r 1               
000000r 1               ;
000000r 1               ; {
000000r 1               ;
000000r 1  20 rr rr     	jsr     pushax
000003r 1               ;
000003r 1               ; register unsigned short i;
000003r 1               ;
000003r 1  A5 rr        	lda     regbank+4
000005r 1  A6 rr        	ldx     regbank+5
000007r 1  20 rr rr     	jsr     pushax
00000Ar 1               ;
00000Ar 1               ; _ck = 0;
00000Ar 1               ;
00000Ar 1  9C rr rr     	stz     __ck
00000Dr 1               ;
00000Dr 1               ; for (i = 0; i < len; ++i)
00000Dr 1               ;
00000Dr 1  64 rr        	stz     regbank+4
00000Fr 1  64 rr        	stz     regbank+4+1
000011r 1  A5 rr        L004F:	lda     regbank+4
000013r 1  A0 02        	ldy     #$02
000015r 1  D1 rr        	cmp     (sp),y
000017r 1  A5 rr        	lda     regbank+4+1
000019r 1  C8           	iny
00001Ar 1  F1 rr        	sbc     (sp),y
00001Cr 1  B0 28        	bcs     L004C
00001Er 1               ;
00001Er 1               ; _ck ^= b[i];
00001Er 1               ;
00001Er 1  AD rr rr     	lda     __ck
000021r 1  20 rr rr     	jsr     pusha0
000024r 1  A0 07        	ldy     #$07
000026r 1  B1 rr        	lda     (sp),y
000028r 1  AA           	tax
000029r 1  88           	dey
00002Ar 1  B1 rr        	lda     (sp),y
00002Cr 1  18           	clc
00002Dr 1  65 rr        	adc     regbank+4
00002Fr 1  85 rr        	sta     ptr1
000031r 1  8A           	txa
000032r 1  65 rr        	adc     regbank+4+1
000034r 1  85 rr        	sta     ptr1+1
000036r 1  B2 rr        	lda     (ptr1)
000038r 1  20 rr rr     	jsr     tosxora0
00003Br 1  8D rr rr     	sta     __ck
00003Er 1               ;
00003Er 1               ; for (i = 0; i < len; ++i)
00003Er 1               ;
00003Er 1  E6 rr        	inc     regbank+4
000040r 1  D0 CF        	bne     L004F
000042r 1  E6 rr        	inc     regbank+4+1
000044r 1  80 CB        	bra     L004F
000046r 1               ;
000046r 1               ; }
000046r 1               ;
000046r 1  B2 rr        L004C:	lda     (sp)
000048r 1  85 rr        	sta     regbank+4
00004Ar 1  A0 01        	ldy     #$01
00004Cr 1  B1 rr        	lda     (sp),y
00004Er 1  85 rr        	sta     regbank+5
000050r 1  4C rr rr     	jmp     incsp6
000053r 1               
000053r 1               .endproc
000053r 1               
000053r 1               ; ---------------------------------------------------------------
000053r 1               ; void __near__ _serial_get_loop (void)
000053r 1               ; ---------------------------------------------------------------
000053r 1               
000053r 1               .segment	"CODE"
000053r 1               
000053r 1               .proc	__serial_get_loop: near
000053r 1               
000053r 1               .segment	"CODE"
000053r 1               
000053r 1               ;
000053r 1               ; while (ser_get(&_r) == SER_ERR_NO_DATA);
000053r 1               ;
000053r 1  A9 rr        L005C:	lda     #<(__r)
000055r 1  A2 rr        	ldx     #>(__r)
000057r 1  20 rr rr     	jsr     _ser_get
00005Ar 1  C9 06        	cmp     #$06
00005Cr 1  F0 F5        	beq     L005C
00005Er 1               ;
00005Er 1               ; }
00005Er 1               ;
00005Er 1  60           	rts
00005Fr 1               
00005Fr 1               .endproc
00005Fr 1               
00005Fr 1               ; ---------------------------------------------------------------
00005Fr 1               ; unsigned char __near__ fnio_init (void)
00005Fr 1               ; ---------------------------------------------------------------
00005Fr 1               
00005Fr 1               .segment	"CODE"
00005Fr 1               
00005Fr 1               .proc	_fnio_init: near
00005Fr 1               
00005Fr 1               .segment	"RODATA"
000000r 1               
000000r 1               L001A:
000000r 1  15           	.byte	$15
000001r 1  03           	.byte	$03
000002r 1  00           	.byte	$00
000003r 1  01           	.byte	$01
000004r 1  00           	.byte	$00
000005r 1               
000005r 1               .segment	"CODE"
00005Fr 1               
00005Fr 1               ;
00005Fr 1               ; };
00005Fr 1               ;
00005Fr 1  20 rr rr     	jsr     decsp5
000062r 1  A0 04        	ldy     #$04
000064r 1  B9 rr rr     L0020:	lda     L001A,y
000067r 1  91 rr        	sta     (sp),y
000069r 1  88           	dey
00006Ar 1  10 F8        	bpl     L0020
00006Cr 1               ;
00006Cr 1               ; ser_install(lynx_comlynx_ser); // This will activate the ComLynx
00006Cr 1               ;
00006Cr 1  A9 rr        	lda     #<(_lynx_comlynx_ser)
00006Er 1  A2 rr        	ldx     #>(_lynx_comlynx_ser)
000070r 1  20 rr rr     	jsr     _ser_install
000073r 1               ;
000073r 1               ; CLI();
000073r 1               ;
000073r 1  58           	cli
000074r 1               ;
000074r 1               ; return ser_open(&params);
000074r 1               ;
000074r 1  A5 rr        	lda     sp
000076r 1  A6 rr        	ldx     sp+1
000078r 1  20 rr rr     	jsr     _ser_open
00007Br 1               ;
00007Br 1               ; }
00007Br 1               ;
00007Br 1  4C rr rr     	jmp     incsp5
00007Er 1               
00007Er 1               .endproc
00007Er 1               
00007Er 1               ; ---------------------------------------------------------------
00007Er 1               ; unsigned char __near__ fnio_done (void)
00007Er 1               ; ---------------------------------------------------------------
00007Er 1               
00007Er 1               .segment	"CODE"
00007Er 1               
00007Er 1               .proc	_fnio_done: near
00007Er 1               
00007Er 1               .segment	"CODE"
00007Er 1               
00007Er 1               ;
00007Er 1               ; return ser_close();
00007Er 1               ;
00007Er 1  4C rr rr     	jmp     _ser_close
000081r 1               
000081r 1               .endproc
000081r 1               
000081r 1               ; ---------------------------------------------------------------
000081r 1               ; void __near__ fnio_reset (unsigned char)
000081r 1               ; ---------------------------------------------------------------
000081r 1               
000081r 1               .segment	"CODE"
000081r 1               
000081r 1               .proc	_fnio_reset: near
000081r 1               
000081r 1               .segment	"CODE"
000081r 1               
000081r 1               ;
000081r 1               ; {
000081r 1               ;
000081r 1  20 rr rr     	jsr     pusha
000084r 1               ;
000084r 1               ; ser_put(MN_RESET | dev);
000084r 1               ;
000084r 1  B2 rr        	lda     (sp)
000086r 1  20 rr rr     	jsr     _ser_put
000089r 1               ;
000089r 1               ; ser_get(&_r);     // get reflection
000089r 1               ;
000089r 1  A9 rr        	lda     #<(__r)
00008Br 1  A2 rr        	ldx     #>(__r)
00008Dr 1  20 rr rr     	jsr     _ser_get
000090r 1               ;
000090r 1               ; }
000090r 1               ;
000090r 1  4C rr rr     	jmp     incsp1
000093r 1               
000093r 1               .endproc
000093r 1               
000093r 1               ; ---------------------------------------------------------------
000093r 1               ; unsigned char __near__ fnio_status (unsigned char, __near__ unsigned char *)
000093r 1               ; ---------------------------------------------------------------
000093r 1               
000093r 1               .segment	"CODE"
000093r 1               
000093r 1               .proc	_fnio_status: near
000093r 1               
000093r 1               .segment	"CODE"
000093r 1               
000093r 1               ;
000093r 1               ; {
000093r 1               ;
000093r 1  20 rr rr     	jsr     pushax
000096r 1               ;
000096r 1               ; ser_put(MN_STATUS | dev);
000096r 1               ;
000096r 1  20 rr rr     	jsr     decsp1
000099r 1  A0 03        	ldy     #$03
00009Br 1  B1 rr        	lda     (sp),y
00009Dr 1  09 10        	ora     #$10
00009Fr 1  20 rr rr     	jsr     _ser_put
0000A2r 1               ;
0000A2r 1               ; ser_get(&_r);      // get reflection
0000A2r 1               ;
0000A2r 1  A9 rr        	lda     #<(__r)
0000A4r 1  A2 rr        	ldx     #>(__r)
0000A6r 1  20 rr rr     	jsr     _ser_get
0000A9r 1               ;
0000A9r 1               ; for (i=0; i<6; ++i) {
0000A9r 1               ;
0000A9r 1  A9 00        	lda     #$00
0000ABr 1  92 rr        L00D0:	sta     (sp)
0000ADr 1  C9 06        	cmp     #$06
0000AFr 1  B0 20        	bcs     L0034
0000B1r 1               ;
0000B1r 1               ; _serial_get_loop();
0000B1r 1               ;
0000B1r 1  20 rr rr     	jsr     __serial_get_loop
0000B4r 1               ;
0000B4r 1               ; buf[i] = _r;
0000B4r 1               ;
0000B4r 1  A2 00        	ldx     #$00
0000B6r 1  B2 rr        	lda     (sp)
0000B8r 1  18           	clc
0000B9r 1  A0 01        	ldy     #$01
0000BBr 1  71 rr        	adc     (sp),y
0000BDr 1  85 rr        	sta     ptr1
0000BFr 1  8A           	txa
0000C0r 1  C8           	iny
0000C1r 1  71 rr        	adc     (sp),y
0000C3r 1  85 rr        	sta     ptr1+1
0000C5r 1  AD rr rr     	lda     __r
0000C8r 1  92 rr        	sta     (ptr1)
0000CAr 1               ;
0000CAr 1               ; for (i=0; i<6; ++i) {
0000CAr 1               ;
0000CAr 1  18           	clc
0000CBr 1  A9 01        	lda     #$01
0000CDr 1  72 rr        	adc     (sp)
0000CFr 1  80 DA        	bra     L00D0
0000D1r 1               ;
0000D1r 1               ; _checksum((unsigned char *) &buf[1], 4);
0000D1r 1               ;
0000D1r 1  A0 02        L0034:	ldy     #$02
0000D3r 1  B1 rr        	lda     (sp),y
0000D5r 1  AA           	tax
0000D6r 1  88           	dey
0000D7r 1  B1 rr        	lda     (sp),y
0000D9r 1  1A           	ina
0000DAr 1  D0 01        	bne     L0042
0000DCr 1  E8           	inx
0000DDr 1  20 rr rr     L0042:	jsr     pushax
0000E0r 1  A2 00        	ldx     #$00
0000E2r 1  A9 04        	lda     #$04
0000E4r 1  20 rr rr     	jsr     __checksum
0000E7r 1               ;
0000E7r 1               ; if (_ck == buf[5])
0000E7r 1               ;
0000E7r 1  AD rr rr     	lda     __ck
0000EAr 1  20 rr rr     	jsr     pusha0
0000EDr 1  A0 04        	ldy     #$04
0000EFr 1  B1 rr        	lda     (sp),y
0000F1r 1  85 rr        	sta     ptr1+1
0000F3r 1  88           	dey
0000F4r 1  B1 rr        	lda     (sp),y
0000F6r 1  85 rr        	sta     ptr1
0000F8r 1  A0 05        	ldy     #$05
0000FAr 1  B1 rr        	lda     (ptr1),y
0000FCr 1  20 rr rr     	jsr     tosicmp0
0000FFr 1  D0 07        	bne     L0044
000101r 1               ;
000101r 1               ; return(1);                      // return success
000101r 1               ;
000101r 1  A2 00        	ldx     #$00
000103r 1  A9 01        	lda     #$01
000105r 1  4C rr rr     	jmp     incsp4
000108r 1               ;
000108r 1               ; return(0);                      // return failure
000108r 1               ;
000108r 1  A2 00        L0044:	ldx     #$00
00010Ar 1  8A           	txa
00010Br 1               ;
00010Br 1               ; }
00010Br 1               ;
00010Br 1  4C rr rr     	jmp     incsp4
00010Er 1               
00010Er 1               .endproc
00010Er 1               
00010Er 1               ; ---------------------------------------------------------------
00010Er 1               ; unsigned char __near__ fnio_send (unsigned char, __near__ unsigned char *, unsigned short)
00010Er 1               ; ---------------------------------------------------------------
00010Er 1               
00010Er 1               .segment	"CODE"
00010Er 1               
00010Er 1               .proc	_fnio_send: near
00010Er 1               
00010Er 1               .segment	"CODE"
00010Er 1               
00010Er 1               ;
00010Er 1               ; {
00010Er 1               ;
00010Er 1  20 rr rr     	jsr     pushax
000111r 1               ;
000111r 1               ; register unsigned short i;
000111r 1               ;
000111r 1  A5 rr        	lda     regbank+4
000113r 1  A6 rr        	ldx     regbank+5
000115r 1  20 rr rr     	jsr     pushax
000118r 1               ;
000118r 1               ; _checksum(buf, len);
000118r 1               ;
000118r 1  A0 07        	ldy     #$07
00011Ar 1  20 rr rr     	jsr     pushwysp
00011Dr 1  A0 05        	ldy     #$05
00011Fr 1  B1 rr        	lda     (sp),y
000121r 1  AA           	tax
000122r 1  88           	dey
000123r 1  B1 rr        	lda     (sp),y
000125r 1  20 rr rr     	jsr     __checksum
000128r 1               ;
000128r 1               ; ser_put(MN_SEND | dev);
000128r 1               ;
000128r 1  A0 06        	ldy     #$06
00012Ar 1  B1 rr        	lda     (sp),y
00012Cr 1  09 60        	ora     #$60
00012Er 1  20 rr rr     	jsr     _ser_put
000131r 1               ;
000131r 1               ; ser_put(len >> 8);
000131r 1               ;
000131r 1  A0 03        	ldy     #$03
000133r 1  B1 rr        	lda     (sp),y
000135r 1  20 rr rr     	jsr     _ser_put
000138r 1               ;
000138r 1               ; ser_put(len & 0xFF);
000138r 1               ;
000138r 1  A0 02        	ldy     #$02
00013Ar 1  B1 rr        	lda     (sp),y
00013Cr 1  20 rr rr     	jsr     _ser_put
00013Fr 1               ;
00013Fr 1               ; for(i=0; i<len; ++i)
00013Fr 1               ;
00013Fr 1  64 rr        	stz     regbank+4
000141r 1  64 rr        	stz     regbank+4+1
000143r 1  A5 rr        L006B:	lda     regbank+4
000145r 1  A0 02        	ldy     #$02
000147r 1  D1 rr        	cmp     (sp),y
000149r 1  A5 rr        	lda     regbank+4+1
00014Br 1  C8           	iny
00014Cr 1  F1 rr        	sbc     (sp),y
00014Er 1  B0 1F        	bcs     L006C
000150r 1               ;
000150r 1               ; ser_put(buf[i]);
000150r 1               ;
000150r 1  A0 05        	ldy     #$05
000152r 1  B1 rr        	lda     (sp),y
000154r 1  AA           	tax
000155r 1  88           	dey
000156r 1  B1 rr        	lda     (sp),y
000158r 1  18           	clc
000159r 1  65 rr        	adc     regbank+4
00015Br 1  85 rr        	sta     ptr1
00015Dr 1  8A           	txa
00015Er 1  65 rr        	adc     regbank+4+1
000160r 1  85 rr        	sta     ptr1+1
000162r 1  B2 rr        	lda     (ptr1)
000164r 1  20 rr rr     	jsr     _ser_put
000167r 1               ;
000167r 1               ; for(i=0; i<len; ++i)
000167r 1               ;
000167r 1  E6 rr        	inc     regbank+4
000169r 1  D0 D8        	bne     L006B
00016Br 1  E6 rr        	inc     regbank+4+1
00016Dr 1  80 D4        	bra     L006B
00016Fr 1               ;
00016Fr 1               ; ser_put(_ck);
00016Fr 1               ;
00016Fr 1  AD rr rr     L006C:	lda     __ck
000172r 1  20 rr rr     	jsr     _ser_put
000175r 1               ;
000175r 1               ; for (i=0; i<(len+4); ++i)
000175r 1               ;
000175r 1  64 rr        	stz     regbank+4
000177r 1  64 rr        	stz     regbank+4+1
000179r 1  A5 rr        L0079:	lda     regbank+4
00017Br 1  A6 rr        	ldx     regbank+4+1
00017Dr 1  20 rr rr     	jsr     pushax
000180r 1  A0 05        	ldy     #$05
000182r 1  B1 rr        	lda     (sp),y
000184r 1  AA           	tax
000185r 1  88           	dey
000186r 1  B1 rr        	lda     (sp),y
000188r 1  18           	clc
000189r 1  69 04        	adc     #$04
00018Br 1  90 01        	bcc     L0081
00018Dr 1  E8           	inx
00018Er 1  20 rr rr     L0081:	jsr     tosicmp
000191r 1  B0 0F        	bcs     L007A
000193r 1               ;
000193r 1               ; ser_get(&_r);
000193r 1               ;
000193r 1  A9 rr        	lda     #<(__r)
000195r 1  A2 rr        	ldx     #>(__r)
000197r 1  20 rr rr     	jsr     _ser_get
00019Ar 1               ;
00019Ar 1               ; for (i=0; i<(len+4); ++i)
00019Ar 1               ;
00019Ar 1  E6 rr        	inc     regbank+4
00019Cr 1  D0 DB        	bne     L0079
00019Er 1  E6 rr        	inc     regbank+4+1
0001A0r 1  80 D7        	bra     L0079
0001A2r 1               ;
0001A2r 1               ; _serial_get_loop();
0001A2r 1               ;
0001A2r 1  20 rr rr     L007A:	jsr     __serial_get_loop
0001A5r 1               ;
0001A5r 1               ; return _r;
0001A5r 1               ;
0001A5r 1  A2 00        	ldx     #$00
0001A7r 1  AD rr rr     	lda     __r
0001AAr 1               ;
0001AAr 1               ; }
0001AAr 1               ;
0001AAr 1  48           	pha
0001ABr 1  B2 rr        	lda     (sp)
0001ADr 1  85 rr        	sta     regbank+4
0001AFr 1  A0 01        	ldy     #$01
0001B1r 1  B1 rr        	lda     (sp),y
0001B3r 1  85 rr        	sta     regbank+5
0001B5r 1  68           	pla
0001B6r 1  4C rr rr     	jmp     incsp7
0001B9r 1               
0001B9r 1               .endproc
0001B9r 1               
0001B9r 1               ; ---------------------------------------------------------------
0001B9r 1               ; unsigned char __near__ fnio_recv (unsigned char, __near__ unsigned char *, __near__ unsigned short *)
0001B9r 1               ; ---------------------------------------------------------------
0001B9r 1               
0001B9r 1               .segment	"CODE"
0001B9r 1               
0001B9r 1               .proc	_fnio_recv: near
0001B9r 1               
0001B9r 1               .segment	"CODE"
0001B9r 1               
0001B9r 1               ;
0001B9r 1               ; {
0001B9r 1               ;
0001B9r 1  20 rr rr     	jsr     pushax
0001BCr 1               ;
0001BCr 1               ; register unsigned short i;
0001BCr 1               ;
0001BCr 1  A5 rr        	lda     regbank+4
0001BEr 1  A6 rr        	ldx     regbank+5
0001C0r 1  20 rr rr     	jsr     pushax
0001C3r 1               ;
0001C3r 1               ; ser_put(MN_RECEIVE | dev);
0001C3r 1               ;
0001C3r 1  A0 06        	ldy     #$06
0001C5r 1  B1 rr        	lda     (sp),y
0001C7r 1  09 40        	ora     #$40
0001C9r 1  20 rr rr     	jsr     _ser_put
0001CCr 1               ;
0001CCr 1               ; ser_get(&_r);           // get reflected data
0001CCr 1               ;
0001CCr 1  A9 rr        	lda     #<(__r)
0001CEr 1  A2 rr        	ldx     #>(__r)
0001D0r 1  20 rr rr     	jsr     _ser_get
0001D3r 1               ;
0001D3r 1               ; _serial_get_loop();      // get response
0001D3r 1               ;
0001D3r 1  20 rr rr     	jsr     __serial_get_loop
0001D6r 1               ;
0001D6r 1               ; if ((_r & 0xF0) == NM_NACK)  // nothing to receive
0001D6r 1               ;
0001D6r 1  AD rr rr     	lda     __r
0001D9r 1  29 F0        	and     #$F0
0001DBr 1  C9 C0        	cmp     #$C0
0001DDr 1  D0 08        	bne     L009D
0001DFr 1               ;
0001DFr 1               ; return _r;           // return NAK
0001DFr 1               ;
0001DFr 1  A2 00        	ldx     #$00
0001E1r 1  AD rr rr     	lda     __r
0001E4r 1  4C rr rr     	jmp     L0097
0001E7r 1               ;
0001E7r 1               ; if (fnio_cts(dev)) {     // clear to send?
0001E7r 1               ;
0001E7r 1  A0 06        L009D:	ldy     #$06
0001E9r 1  B1 rr        	lda     (sp),y
0001EBr 1  20 rr rr     	jsr     _fnio_cts
0001EEr 1  AA           	tax
0001EFr 1  D0 03 4C rr  	jeq     L00A2
0001F3r 1  rr           
0001F4r 1               ;
0001F4r 1               ; _serial_get_loop();
0001F4r 1               ;
0001F4r 1  20 rr rr     	jsr     __serial_get_loop
0001F7r 1               ;
0001F7r 1               ; *len = _r << 8;
0001F7r 1               ;
0001F7r 1  A0 03        	ldy     #$03
0001F9r 1  B1 rr        	lda     (sp),y
0001FBr 1  85 rr        	sta     ptr1+1
0001FDr 1  88           	dey
0001FEr 1  B1 rr        	lda     (sp),y
000200r 1  85 rr        	sta     ptr1
000202r 1  A9 00        	lda     #$00
000204r 1  92 rr        	sta     (ptr1)
000206r 1  88           	dey
000207r 1  AD rr rr     	lda     __r
00020Ar 1  91 rr        	sta     (ptr1),y
00020Cr 1               ;
00020Cr 1               ; _serial_get_loop();
00020Cr 1               ;
00020Cr 1  20 rr rr     	jsr     __serial_get_loop
00020Fr 1               ;
00020Fr 1               ; *len |= _r & 0xFF;
00020Fr 1               ;
00020Fr 1  A0 03        	ldy     #$03
000211r 1  B1 rr        	lda     (sp),y
000213r 1  AA           	tax
000214r 1  88           	dey
000215r 1  B1 rr        	lda     (sp),y
000217r 1  20 rr rr     	jsr     pushax
00021Ar 1  85 rr        	sta     ptr1
00021Cr 1  86 rr        	stx     ptr1+1
00021Er 1  A0 01        	ldy     #$01
000220r 1  B1 rr        	lda     (ptr1),y
000222r 1  AA           	tax
000223r 1  88           	dey
000224r 1  B2 rr        	lda     (ptr1)
000226r 1  85 rr        	sta     ptr1
000228r 1  86 rr        	stx     ptr1+1
00022Ar 1  AD rr rr     	lda     __r
00022Dr 1  05 rr        	ora     ptr1
00022Fr 1  A6 rr        	ldx     ptr1+1
000231r 1  20 rr rr     	jsr     staxspidx
000234r 1               ;
000234r 1               ; if (*len > LEN_MAX)       // no more than LEN_MAX bytes
000234r 1               ;
000234r 1  A0 03        	ldy     #$03
000236r 1  B1 rr        	lda     (sp),y
000238r 1  85 rr        	sta     ptr1+1
00023Ar 1  88           	dey
00023Br 1  B1 rr        	lda     (sp),y
00023Dr 1  85 rr        	sta     ptr1
00023Fr 1  88           	dey
000240r 1  B1 rr        	lda     (ptr1),y
000242r 1  AA           	tax
000243r 1  B2 rr        	lda     (ptr1)
000245r 1  C9 01        	cmp     #$01
000247r 1  8A           	txa
000248r 1  E9 04        	sbc     #$04
00024Ar 1  90 14        	bcc     L00D3
00024Cr 1               ;
00024Cr 1               ; *len = LEN_MAX;
00024Cr 1               ;
00024Cr 1  A0 03        	ldy     #$03
00024Er 1  B1 rr        	lda     (sp),y
000250r 1  85 rr        	sta     ptr1+1
000252r 1  88           	dey
000253r 1  B1 rr        	lda     (sp),y
000255r 1  85 rr        	sta     ptr1
000257r 1  A9 00        	lda     #$00
000259r 1  92 rr        	sta     (ptr1)
00025Br 1  88           	dey
00025Cr 1  A9 04        	lda     #$04
00025Er 1  91 rr        	sta     (ptr1),y
000260r 1               ;
000260r 1               ; for (i=0; i<*len; ++i) {
000260r 1               ;
000260r 1  64 rr        L00D3:	stz     regbank+4
000262r 1  64 rr        	stz     regbank+4+1
000264r 1  A5 rr        L00AF:	lda     regbank+4
000266r 1  A6 rr        	ldx     regbank+4+1
000268r 1  20 rr rr     	jsr     pushax
00026Br 1  A0 05        	ldy     #$05
00026Dr 1  B1 rr        	lda     (sp),y
00026Fr 1  85 rr        	sta     ptr1+1
000271r 1  88           	dey
000272r 1  B1 rr        	lda     (sp),y
000274r 1  85 rr        	sta     ptr1
000276r 1  A0 01        	ldy     #$01
000278r 1  B1 rr        	lda     (ptr1),y
00027Ar 1  AA           	tax
00027Br 1  B2 rr        	lda     (ptr1)
00027Dr 1  20 rr rr     	jsr     tosicmp
000280r 1  B0 22        	bcs     L00B0
000282r 1               ;
000282r 1               ; _serial_get_loop();
000282r 1               ;
000282r 1  20 rr rr     	jsr     __serial_get_loop
000285r 1               ;
000285r 1               ; buf[i] = _r;
000285r 1               ;
000285r 1  A0 05        	ldy     #$05
000287r 1  B1 rr        	lda     (sp),y
000289r 1  AA           	tax
00028Ar 1  88           	dey
00028Br 1  B1 rr        	lda     (sp),y
00028Dr 1  18           	clc
00028Er 1  65 rr        	adc     regbank+4
000290r 1  85 rr        	sta     ptr1
000292r 1  8A           	txa
000293r 1  65 rr        	adc     regbank+4+1
000295r 1  85 rr        	sta     ptr1+1
000297r 1  AD rr rr     	lda     __r
00029Ar 1  92 rr        	sta     (ptr1)
00029Cr 1               ;
00029Cr 1               ; for (i=0; i<*len; ++i) {
00029Cr 1               ;
00029Cr 1  E6 rr        	inc     regbank+4
00029Er 1  D0 C4        	bne     L00AF
0002A0r 1  E6 rr        	inc     regbank+4+1
0002A2r 1  80 C0        	bra     L00AF
0002A4r 1               ;
0002A4r 1               ; _serial_get_loop();
0002A4r 1               ;
0002A4r 1  20 rr rr     L00B0:	jsr     __serial_get_loop
0002A7r 1               ;
0002A7r 1               ; _checksum(buf, *len);
0002A7r 1               ;
0002A7r 1  A0 07        	ldy     #$07
0002A9r 1  20 rr rr     	jsr     pushwysp
0002ACr 1  A0 05        	ldy     #$05
0002AEr 1  B1 rr        	lda     (sp),y
0002B0r 1  85 rr        	sta     ptr1+1
0002B2r 1  88           	dey
0002B3r 1  B1 rr        	lda     (sp),y
0002B5r 1  85 rr        	sta     ptr1
0002B7r 1  A0 01        	ldy     #$01
0002B9r 1  B1 rr        	lda     (ptr1),y
0002BBr 1  AA           	tax
0002BCr 1  B2 rr        	lda     (ptr1)
0002BEr 1  20 rr rr     	jsr     __checksum
0002C1r 1               ;
0002C1r 1               ; if (_r == _ck)
0002C1r 1               ;
0002C1r 1  AD rr rr     	lda     __ck
0002C4r 1  CD rr rr     	cmp     __r
0002C7r 1  D0 0B        	bne     L00C0
0002C9r 1               ;
0002C9r 1               ; ser_put(MN_ACK | dev);        // ACK
0002C9r 1               ;
0002C9r 1  A0 06        	ldy     #$06
0002CBr 1  B1 rr        	lda     (sp),y
0002CDr 1  09 20        	ora     #$20
0002CFr 1  20 rr rr     	jsr     _ser_put
0002D2r 1               ;
0002D2r 1               ; else {
0002D2r 1               ;
0002D2r 1  80 1B        	bra     L00C4
0002D4r 1               ;
0002D4r 1               ; ser_put(MN_NACK | dev);        // NACK, checksum bad
0002D4r 1               ;
0002D4r 1  A0 06        L00C0:	ldy     #$06
0002D6r 1  B1 rr        	lda     (sp),y
0002D8r 1  09 70        	ora     #$70
0002DAr 1  20 rr rr     	jsr     _ser_put
0002DDr 1               ;
0002DDr 1               ; *len = 0;                   // return zero length
0002DDr 1               ;
0002DDr 1  A0 03        	ldy     #$03
0002DFr 1  B1 rr        	lda     (sp),y
0002E1r 1  85 rr        	sta     ptr1+1
0002E3r 1  88           	dey
0002E4r 1  B1 rr        	lda     (sp),y
0002E6r 1  85 rr        	sta     ptr1
0002E8r 1  A9 00        	lda     #$00
0002EAr 1  92 rr        	sta     (ptr1)
0002ECr 1  88           	dey
0002EDr 1  91 rr        	sta     (ptr1),y
0002EFr 1               ;
0002EFr 1               ; ser_get((char *) &_r);          // get reflected data
0002EFr 1               ;
0002EFr 1  A9 rr        L00C4:	lda     #<(__r)
0002F1r 1  A2 rr        	ldx     #>(__r)
0002F3r 1  20 rr rr     	jsr     _ser_get
0002F6r 1               ;
0002F6r 1               ; else {
0002F6r 1               ;
0002F6r 1  80 11        	bra     L00CB
0002F8r 1               ;
0002F8r 1               ; *len = 0;                      // zero bytes received
0002F8r 1               ;
0002F8r 1  A0 03        L00A2:	ldy     #$03
0002FAr 1  B1 rr        	lda     (sp),y
0002FCr 1  85 rr        	sta     ptr1+1
0002FEr 1  88           	dey
0002FFr 1  B1 rr        	lda     (sp),y
000301r 1  85 rr        	sta     ptr1
000303r 1  8A           	txa
000304r 1  92 rr        	sta     (ptr1)
000306r 1  88           	dey
000307r 1  91 rr        	sta     (ptr1),y
000309r 1               ;
000309r 1               ; return (NM_ACK | dev);             // return ACK (change to true/false return? -SJ)
000309r 1               ;
000309r 1  A0 06        L00CB:	ldy     #$06
00030Br 1  B1 rr        	lda     (sp),y
00030Dr 1  09 90        	ora     #$90
00030Fr 1  A2 00        	ldx     #$00
000311r 1               ;
000311r 1               ; }
000311r 1               ;
000311r 1  48           L0097:	pha
000312r 1  B2 rr        	lda     (sp)
000314r 1  85 rr        	sta     regbank+4
000316r 1  A0 01        	ldy     #$01
000318r 1  B1 rr        	lda     (sp),y
00031Ar 1  85 rr        	sta     regbank+5
00031Cr 1  68           	pla
00031Dr 1  4C rr rr     	jmp     incsp7
000320r 1               
000320r 1               .endproc
000320r 1               
000320r 1               ; ---------------------------------------------------------------
000320r 1               ; unsigned char __near__ fnio_cts (unsigned char)
000320r 1               ; ---------------------------------------------------------------
000320r 1               
000320r 1               .segment	"CODE"
000320r 1               
000320r 1               .proc	_fnio_cts: near
000320r 1               
000320r 1               .segment	"CODE"
000320r 1               
000320r 1               ;
000320r 1               ; {
000320r 1               ;
000320r 1  20 rr rr     	jsr     pusha
000323r 1               ;
000323r 1               ; ser_put(MN_CLR | dev);
000323r 1               ;
000323r 1  B2 rr        	lda     (sp)
000325r 1  09 30        	ora     #$30
000327r 1  20 rr rr     	jsr     _ser_put
00032Ar 1               ;
00032Ar 1               ; ser_get(&_r);   // get reflected data
00032Ar 1               ;
00032Ar 1  A9 rr        	lda     #<(__r)
00032Cr 1  A2 rr        	ldx     #>(__r)
00032Er 1  20 rr rr     	jsr     _ser_get
000331r 1               ;
000331r 1               ; _serial_get_loop();
000331r 1               ;
000331r 1  20 rr rr     	jsr     __serial_get_loop
000334r 1               ;
000334r 1               ; if ((_r & 0xF0) == NM_SEND)
000334r 1               ;
000334r 1  AD rr rr     	lda     __r
000337r 1  A2 00        	ldx     #$00
000339r 1  29 F0        	and     #$F0
00033Br 1  C9 B0        	cmp     #$B0
00033Dr 1  D0 05        	bne     L00D4
00033Fr 1               ;
00033Fr 1               ; return(1);
00033Fr 1               ;
00033Fr 1  A9 01        	lda     #$01
000341r 1  4C rr rr     	jmp     incsp1
000344r 1               ;
000344r 1               ; return(0);
000344r 1               ;
000344r 1  8A           L00D4:	txa
000345r 1               ;
000345r 1               ; }
000345r 1               ;
000345r 1  4C rr rr     	jmp     incsp1
000348r 1               
000348r 1               .endproc
000348r 1               
000348r 1               
